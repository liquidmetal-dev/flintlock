package models

import (
	"fmt"
	"net"
	"strings"
)

// NetworkInterface represents a network interface for the microvm.
type NetworkInterface struct {
	// GuestDeviceName is the name of the network interface to create in the microvm.
	GuestDeviceName string `json:"guest_device_name" validate:"required,excludesall=/@,guestDeviceName"`
	// AllowMetadataRequests indicates that this interface can be used for metadata requests.
	//
	// NOTE: This field is not exposed via the gRPC API, it is automatically
	// populated when converting from the API model to this internal model.
	// TODO: we may hide this within the firecracker plugin. #179
	AllowMetadataRequests bool `json:"allow_mmds,omitempty"`
	// GuestMAC allows the specifying of a specifi MAC address to use for the interface. If
	// not supplied a autogenerated MAC address will be used.
	GuestMAC string `json:"guest_mac,omitempty" validate:"omitempty,mac"`
	// Type is the type of host network interface type to create to use by the guest.
	Type IfaceType `json:"type" validate:"oneof=tap macvtap unsupported"`
	// StaticAddress is an optional static IP address to assign to this interface.
	// If not supplied then DHCP will be used.
	StaticAddress *StaticAddress `json:"staticAddrss,omitempty"`
	// BridgeName is the name of the Linux bridge to attach the TAP device to.
	BridgeName string `json:"branch_name,omitempty"`
}

// StaticAddress specifies a static IP address configuration.
type StaticAddress struct {
	// Address is the static IP address (IPv4 or IPv6) to assign to this interface.
	// Must be CIDR notation.
	Address IPAddressCIDR `json:"address" validate:"cidr"`
	// Gateway is used to optionally set the default gateway for IPv4 or IPv6.
	Gateway *IPAddressCIDR `json:"gateway,omitempty" validate:"omitempty,cidr"`
	// Nameservers allows you to optionally specify nameservers for the interface.
	Nameservers []string `json:"nameservers" validate:"omitempty,dive,ip"`
}

// IPAddressCIDR represents a IPv4/IPv6 address in CIDR notation.
type IPAddressCIDR string

func (i IPAddressCIDR) IsIPv4() (bool, error) {
	ip, _, err := net.ParseCIDR(string(i))
	if err != nil {
		return false, fmt.Errorf("parsing %s as cidr: %w", i, err)
	}

	// 0:0:0:0:0:ffff:0101:0101 is the ipv6 representation of 1.1.1.1, the net
	// package can parse and convert to IPv4. Based on Slack messages, we want a
	// strict validation, they have to spcify an IPv4 CIDR block.
	containsDot := strings.Contains(string(i), ".")

	return ip.To4() != nil && containsDot, nil
}

func (i IPAddressCIDR) IP() (string, error) {
	if _, _, err := net.ParseCIDR(string(i)); err != nil {
		return "", fmt.Errorf("parsing %s as cidr: %w", i, err)
	}

	// We don't have to test if we can get IPv6 or IPv4 address with To4 or
	// To16 because ParseCIDR returns with an error if it's neither of them.
	slashIndex := strings.Index(string(i), "/")

	return string(i)[:slashIndex], nil
}

type NetworkInterfaceStatus struct {
	// HostDeviceName is the name of the network interface used from the host. This will be
	// a tuntap or macvtap interface.
	HostDeviceName string `json:"host_device_name"`
	// Index is the index of the network interface on the host.
	Index int `json:"index"`
	// MACAddress is the MAC address of the host interface.
	MACAddress string `json:"mac_address"`
}

// NetworkInterfaceStatuses is a collection of network interfaces.
type NetworkInterfaceStatuses map[string]*NetworkInterfaceStatus

// IfaceType is a type representing the supported network interface types.
type IfaceType string

const (
	// IfaceTypeTap is a TAP network interface.
	IfaceTypeTap IfaceType = "tap"
	// IfaceTypeMacvtap is a MACVTAP network interface.
	IfaceTypeMacvtap IfaceType = "macvtap"
	// IfaceTypeUnsupported is a type that represents an unsupported network interface type.
	IfaceTypeUnsupported IfaceType = "unsupported"
)
